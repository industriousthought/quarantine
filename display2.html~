
<html>

    <head>


        <!--<link rel="stylesheet" type="text/css" href="./css/reset.css" />-->
    


        <!--<script src="/socket.io/socket.io.js"></script>-->
<script>
    
    function matrixMultiply(a,b) {
        var a00=a[0*3+0];
        var a01=a[0*3+1];
        var a02=a[0*3+2];
        var a10=a[1*3+0];
        var a11=a[1*3+1];
        var a12=a[1*3+2];
        var a20=a[2*3+0];
        var a21=a[2*3+1];
        var a22=a[2*3+2];
        var b00=b[0*3+0];
        var b01=b[0*3+1];
        var b02=b[0*3+2];
        var b10=b[1*3+0];
        var b11=b[1*3+1];
        var b12=b[1*3+2];
        var b20=b[2*3+0];
        var b21=b[2*3+1];
        var b22=b[2*3+2];
        return [a00*b00+a01*b10+a02*b20,a00*b01+a01*b11+a02*b21,a00*b02+a01*b12+a02*b22,a10*b00+a11*b10+a12*b20,a10*b01+a11*b11+a12*b21,a10*b02+a11*b12+a12*b22,a20*b00+a21*b10+a22*b20,a20*b01+a21*b11+a22*b21,a20*b02+a21*b12+a22*b22];
    }

function makeTranslation(tx, ty) {
  return [
    1, 0, 0,
    0, 1, 0,
    tx, ty, 1
  ];
}

function makeRotation(angleInRadians) {
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  return [
    c,-s, 0,
    s, c, 0,
    0, 0, 1
  ];
}

function makeScale(sx, sy) {
  return [
    sx, 0, 0,
    0, sy, 0,
    0, 0, 1
  ];
}
    
var loadProgram = function(gl, shaders, opt_attribs, opt_locations) {
  var program = gl.createProgram();
  for (var ii = 0; ii < shaders.length; ++ii) {
    gl.attachShader(program, shaders[ii]);
  }
  if (opt_attribs) {
    for (var ii = 0; ii < opt_attribs.length; ++ii) {
      gl.bindAttribLocation(
          program,
          opt_locations ? opt_locations[ii] : ii,
          opt_attribs[ii]);
    }
  }
  gl.linkProgram(program);

  // Check the link status
  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!linked) {
      // something went wrong with the link
      lastError = gl.getProgramInfoLog (program);
      error("Error in program linking:" + lastError);

      gl.deleteProgram(program);
      return null;
  }
  return program;
};
    

var error = function(msg) {
  if (window.console) {
    if (window.console.error) {
      window.console.error(msg);
    }
    else if (window.console.log) {
      window.console.log(msg);
    }
  }
};
    
var createShaderFromScript = function (gl, scriptId, opt_shaderType, opt_errorCallback) {
  var shaderSource = "";
  var shaderType;
  var shaderScript = document.getElementById(scriptId);
  if (!shaderScript) {
    throw("*** Error: unknown script element" + scriptId);
  }
  shaderSource = shaderScript.text;

  if (!opt_shaderType) {
    if (shaderScript.type == "x-shader/x-vertex") {
      shaderType = gl.VERTEX_SHADER;
    } else if (shaderScript.type == "x-shader/x-fragment") {
      shaderType = gl.FRAGMENT_SHADER;
    } else if (shaderType != gl.VERTEX_SHADER && shaderType != gl.FRAGMENT_SHADER) {
      throw("*** Error: unknown shader type");
      return null;
    }
  }

  return loadShader(
      gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,
      opt_errorCallback);
};

var loadShader = function(gl, shaderSource, shaderType, opt_errorCallback) {
  var errFn = opt_errorCallback || error;
  // Create the shader object
  var shader = gl.createShader(shaderType);

  // Load the shader source
  gl.shaderSource(shader, shaderSource);

  // Compile the shader
  gl.compileShader(shader);

  // Check the compile status
  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (!compiled) {
    // Something went wrong during compilation; get the error
    lastError = gl.getShaderInfoLog(shader);
    errFn("*** Error compiling shader '" + shader + "':" + lastError);
    gl.deleteShader(shader);
    return null;
  }

  return shader;
}

if (!window.requestAnimationFrame) {
  window.requestAnimationFrame = (window.webkitRequestAnimationFrame ||
                                  window.mozRequestAnimationFrame ||
                                  window.msRequestAnimationFrame ||
                                  window.oRequestAnimationFrame ||
                                  function (callback) {
                                    return window.setTimeout(callback, 17 /*~ 1000/60*/);
                                  });
}

if (!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||
                                 window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame ||
                                 window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||
                                 window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||
                                 window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||
                                 window.clearTimeout);
}

/*
  var socket = io.connect('http://localhost/dis');
  socket.on('event', function (data) {
      if (data.newPlayer) {
          var newPos = getNewPlayerCoordinates();
          globalObj.running = true;
          newPlayer({id: data.newPlayer, nick: data.nick, x: newPos.x, y: newPos.y});
          main();
          console.log(data.newPlayer);

      };

      if (data.controller == 'leftJoystick' && globalObj.players[data.id]) {
          if (data.x || data.y) {
              console.log(data.id + ', ' + data.x);
              globalObj.players[data.id].x -= data.x * 2;
              globalObj.players[data.id].y -= data.y * 2;
              globalObj.players[data.id].speed = Math.sqrt(Math.pow(data.x, 2) + Math.pow(data.y, 2));
              if (!globalObj.players[data.id].shooting) {
                  globalObj.players[data.id].rotation = Math.atan2(data.x, data.y) + (Math.PI / 2);
              }
              if (!globalObj.players[data.id].moving) {
                  globalObj.players[data.id].moving = 1;
              }
          } else {
              globalObj.players[data.id].moving = null;
          }

      }

      if (data.controller == 'rightJoystick' && globalObj.players[data.id]) {

          if (data.x) {
              globalObj.players[data.id].shooting = true;
              globalObj.players[data.id].rotation = Math.atan2(data.x, data.y) + (Math.PI / 2);
          } else {

              globalObj.players[data.id].shooting = false;
          }

      }
  });
*/
    var getNewPlayerCoordinates = function() {
        return {x: 200, y: 200};
    };

    var getNewZombieCoordinates = function() {
        var locations = [
            {x: 0, y: 300},
            {x: 300, y: 0},
            {x: window.innerWidth, y: 0},
            {x: 0, y: window.innerHeight}

        ];
        var i = Math.floor(Math.random() * 4);

        return locations[i];
    };

  var TextureMap = function(p) {
    var horizontalNum = p.horizontalNum;
    var verticalNum = p.verticalNum;
    var currentTile = [0, 0];
    

    this.getTile = function(tile) {
        if (tile) {
            if (tile == 'next') {
                currentTile[1] = 0;
                if (currentTile[0] < horizontalNum - 1) {
                    currentTile[0]++;
                } else {
                    currentTile[0] = 0;
                } 

                currentTile[1] = 0;

            } else {
             
                currentTile[0] = tile[0];
                currentTile[1] = tile[1];
            }
        }

        return {minX: (1 / horizontalNum) * currentTile[0], maxX: (1 / horizontalNum) * (currentTile[0] + 1), minY: (1 / verticalNum) * currentTile[1], maxY: (1 / verticalNum) * (currentTile[1] + 1)  }

    
    };

  };

</script>

<script id="2d-vertex-shader" type="x-shader/x-vertex">
attribute vec2 a_position;
attribute vec2 a_texCoord;

uniform vec2 u_resolution;
uniform mat3 u_matrix;

varying vec2 v_texCoord;


void main() {

// Multiply the position by the matrix.
  vec2 position = (u_matrix * vec3(a_position, 1)).xy;

  // convert the position from pixels to 0.0 to 1.0
  vec2 zeroToOne = position / u_resolution;

  // convert from 0->1 to 0->2
  vec2 zeroToTwo = zeroToOne * 2.0;

  // convert from 0->2 to -1->+1 (clipspace)
  vec2 clipSpace = zeroToTwo - 1.0;

  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
   v_texCoord = a_texCoord;
}
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// RJ Suggestion : Since we are using one texture at a time, we just need one 
// sampler2D defined inside our shader. So set it only ones in your code
		
// our texture
uniform sampler2D u_image0;
uniform sampler2D u_image1;
uniform sampler2D u_image2;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
// Look up a color from the texture.
vec4 textureColor = texture2D(u_image0, v_texCoord);
  if (textureColor.a < 0.5) 
    discard;
  else
    gl_FragColor = vec4(textureColor.rgb, textureColor.a);
	
	// RJ Changes : We do not need other shader code 
	
	
}
</script>


    </head>


    <body onload="init();" style="background: #0000FF">
        <canvas id="display" style="width: 100%; height: 100%; top: 0px; left: 0px; position: absolute"> 

        </canvas>

        <script>

// Get A WebGL context
var canvas = document.getElementById("display");
canvas.setAttribute('width', window.innerWidth);
canvas.setAttribute('height', window.innerHeight);
var gl = canvas.getContext("experimental-webgl");
var globalGL = {};
var globalObj = {};



// setup a GLSL program
var vertexShader = createShaderFromScript(gl, "2d-vertex-shader");
var fragmentShader = createShaderFromScript(gl, "2d-fragment-shader");
globalGL.program = loadProgram(gl, [vertexShader, fragmentShader]);
gl.useProgram(globalGL.program);

// look up where the vertex data needs to go.
globalGL.positionLocation = gl.getAttribLocation(globalGL.program, "a_position");

globalGL.translationLocation = gl.getUniformLocation(globalGL.program, "u_translation");

//Get rotation location
globalGL.rotationLocation = gl.getUniformLocation(globalGL.program, "u_rotation");

// set the resolution
globalGL.resolutionLocation = gl.getUniformLocation(globalGL.program, "u_resolution");
gl.uniform2f(globalGL.resolutionLocation, canvas.width, canvas.height);


var types = {
    'player': {image: './hero.png', textureIndex: 0, activeTex: gl.TEXTURE0, width: 50, height: 50, texHorizontalNum: 6, texVerticalNum: 2},
    'zombie': {image: './zombie.png', textureIndex: 1, activeTex: gl.TEXTURE1, width: 50, height: 50, texHorizontalNum: 6, texVerticalNum: 2},
    'bullet': {image: './bullet.png', textureIndex: 2, activeTex: gl.TEXTURE2, width: 4, height: 4, texHorizontalNum: 1, texVerticalNum: 1}   

};

var initTextures = function() {
    var i;
    for (i in types) {

        (function (){
            var index = i;
            var image = new Image();
            image.onload = function() {
                types[index].vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, types[index].vertexBuffer);

                var xMin = 0;
                var xMax = types[index].width;
                var yMin = 0;
                var yMax = types[index].height;


                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    xMin, yMax,
                    xMax, yMax,
                    xMin, yMin,
                    xMin, yMin,
                    xMax, yMax,
                    xMax, yMin]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(globalGL.positionLocation);
                gl.vertexAttribPointer(globalGL.positionLocation, 2, gl.FLOAT, false, 0, 0);

        types[index].texCoordLocation = gl.getAttribLocation(globalGL.program, 'a_texCoord');
        

        types[index].texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, types[index].texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0,  1,
            1,  1,
            0,  0,
            0,  0,
            1,  1,
            1,  0]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(types[index].texCoordLocation);
        gl.vertexAttribPointer(types[index].texCoordLocation, 2, gl.FLOAT, false, 0, 0);

                // Create a texture.
                types[index].texture = gl.createTexture();
                types[index].u_imageLocation = gl.getUniformLocation(globalGL.program, "u_image" + types[index].textureIndex);
                gl.uniform1i(types[index].u_imageLocation, types[index].textureIndex); 

                //gl.activeTexture(gl.TEXTURE0 + types[index].textureIndex);
                gl.bindTexture(gl.TEXTURE_2D, types[index].texture);


                // Upload the image into the texture.
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

                // Set the parameters so we can render any size image.
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

                gl.bindTexture(gl.TEXTURE_2D, null);



            };

            image.src = types[i].image;  
        })();
    }
};


var Agent = function (p) {
    this.textureIndex = p.textureIndex;
    this.texHorizontalNum = p.texHorizontalNum;
    this.texVerticalNum = p.texVerticalNum;
    this.id = p.id;
    this.width = p.width;
    this.height = p.height;
    this.x = p.x;
    this.y = p.y;
    this.rotation = 0;
    this.texMap = new TextureMap({horizontalNum: this.texHorizontalNum, verticalNum: this.texVerticalNum});

    globalObj.agents[this.id] = this;

    this.draw = function() {

        var tex, i;

        if (this.shooting) {
            tex = this.texMap.getTile([0, 1]);
        } else if ( this.moving) {

            if (this.moving < 15 / this.speed) {
                this.moving++;
                tex = this.texMap.getTile();
            } else {
                 this.moving = 1;
                tex = this.texMap.getTile('next');
            }
        } else {
            tex = this.texMap.getTile([0, 0]);
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, types[this.type].vertexBuffer);
        gl.vertexAttribPointer(globalGL.positionLocation, 2, gl.FLOAT, false, 0, 0);

        types[this.type].texCoordLocation = gl.getAttribLocation(globalGL.program, 'a_texCoord');
        

        gl.bindBuffer(gl.ARRAY_BUFFER, types[this.type].texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            tex.minX,  tex.maxY,
            tex.maxX,  tex.maxY,
            tex.minX,  tex.minY,
            tex.minX,  tex.minY,
            tex.maxX,  tex.maxY,
            tex.maxX,  tex.minY]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(types[this.type].texCoordLocation);
        gl.vertexAttribPointer(types[this.type].texCoordLocation, 2, gl.FLOAT, false, 0, 0);
            
        var matrixLocation = gl.getUniformLocation(globalGL.program,'u_matrix');

        var centerTranslation = [-this.width / 2, -this.height / 2];
        var decenterTranslation = [this.width / 2 , this.height / 2];
        var translation = [this.x, this.y];
        var angleInRadians = this.rotation;
        var scale = [1, 1];

        // Compute the matrices
        var centerTranslationMatrix = makeTranslation(centerTranslation[0], centerTranslation[1]);
        var decenterTranslationMatrix = makeTranslation(decenterTranslation[0], decenterTranslation[1]);
        var translationMatrix = makeTranslation(translation[0], translation[1]);
        var rotationMatrix = makeRotation(angleInRadians);
        var scaleMatrix = makeScale(scale[0], scale[1]);

        // Multiply the matrices.
        var matrix = matrixMultiply(scaleMatrix, centerTranslationMatrix);
        matrix = matrixMultiply(matrix, rotationMatrix);
        matrix = matrixMultiply(matrix, decenterTranslationMatrix);
        matrix = matrixMultiply(matrix, translationMatrix);

        // Set the matrix.
        gl.uniformMatrix3fv(matrixLocation, false, matrix);

		// RJ Changes 
        
		// Original Code 
		// gl.activeTexture(gl.TEXTURE0 + this.textureIndex);
		
		// RJ : Changed Code  : At a time you want to use only one texture depending upon 
		// whether it is a hero or zombie. So no need to initialize the different 
		// texture units. Since we are using one texture at a time in shader bind the 
		// texture to be used 
		gl.activeTexture(gl.TEXTURE0);
		
        gl.bindTexture(gl.TEXTURE_2D, types[this.type].texture);
		
		// RJ Suggestion : Since we are using one texture at a time, we just need one 
		// sampler2D defined inside our shader. So set it only ones in your code
        gl.uniform1i(types[this.type].u_imageLocation, types[this.type].textureIndex); 

        // draw
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        //doesn't strictly need to be here I don't think
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
};


var newBullet = function(p) {
    var agent = new Agent({image: './bullet.png', id: p.id, x: p.x, y: p.y, textureIndex: 2, activeTex: gl.TEXTURE2, width: 4, height: 4, texHorizontalNum: 1, texVerticalNum: 1});
    agent.type = 'bullet';

    agent.vector = p.vector;

    agent.collision = {
        radius: 50,
        zombie: function(p) {
            delete globalObj.agents[p.j];
            globalObj.agents[p.i].kill = true;
            //globalObj.agents[p.j].hit = true;
        }
    };

    agent.logic = function() {
        this.x += this.vector.x * 2;
        this.y -= this.vector.y * 2;
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
            this.kill = true;
        }
    }

};

var newPlayer = function(p) {
    var agent = new Agent({image: './hero.png', id: p.id, x: p.x, y: p.y, textureIndex: 0, activeTex: gl.TEXTURE0, width: 50, height: 50, texHorizontalNum: 6, texVerticalNum: 2});

    agent.type = 'player';
    agent.reloading = false;

    agent.logic = function() {
        if (this.shooting) {
            if (!this.reloading) {
                newBullet({x: this.x + (this.width / 2), y: this.y + (this.height / 2), vector: {x: Math.cos(this.rotation) * 2, y: Math.sin(this.rotation) * 2}, id: globalObj.lastBulletId++});
                this.reloading = new Date();
            } else {
                if (new Date() - this.reloading > 250)
                this.reloading = false;
            }
        };

    };

    agent.nick = p.nick;
    agent.collision = {
        radius: 20,
        player: function(p) {
        
        },
        zombie: function(p) {

        }

    };

    globalObj.players[agent.id] = agent;


    //alert(agent.nick);
};


var newZombie = function(p) {
    var agent = new Agent({image: './zombie.png', id: p.id, x: p.x, y: p.y, textureIndex: 1, activeTex: gl.TEXTURE1, width: 50, height: 50, texHorizontalNum: 6, texVerticalNum: 2});
    agent.speed = (Math.random() * 1) + 1;
    agent.runner = Math.floor(Math.random() * 10);
    agent.moving = true;

    agent.collision = {
        radius: 20,
        player: function(p) {
            delete globalObj.agents[p.j];
            delete globalObj.players[p.j];
            //socket.emit('deadPlayer', {
                //id: p.j
            //});
        
        },
        zombie: function(p) {
            globalObj.agents[p.i].x -= (20 - p.xDif) / 50;
            globalObj.agents[p.i].y -= (20 - p.yDif) / 50;

        }

    };
    agent.type = 'zombie';
    agent.logic = function() {
        var closestPlayer = {};
        var i, xDif, yDif, speed;
        for (i in globalObj.players) {
            xDif = globalObj.players[i].x - this.x;
            yDif = globalObj.players[i].y - this.y;
            if (!closestPlayer.id || Math.sqrt(Math.pow(xDif, 2) + (Math.pow(yDif, 2))) < closestPlayer.distance) {
                closestPlayer.id = i;
                closestPlayer.distance = Math.sqrt(Math.pow(xDif, 2) + (Math.pow(yDif, 2)));
                closestPlayer.xDif = xDif;
                closestPlayer.yDif = yDif;
            }

        }

        if (this.runner > 5 && closestPlayer.distance < 500) {
            speed = this.speed * 1.5;
            //console.log('runnning!');
        } else {
            speed = this.speed;
        }
        
        this.rotation = Math.atan2(xDif, yDif) - (Math.PI / 2);
        if (globalObj.players[closestPlayer.id]) {
            if (globalObj.players[closestPlayer.id].x < this.x) {
                this.x -= speed;
            } else {
                this.x += speed;
            }
            if (globalObj.players[closestPlayer.id].y < this.y) {
                this.y -= speed;
            } else {
                this.y += speed;
            }
        }

    };

};


var eventLoop = function() {
    gl.clear(gl.COLOR_BUFFER_BIT);


    var i, j, yDif, xDif, coordinates;
    var now = new Date();
    var playerCount = 0;

    if (now - globalObj.lastZombieTime > 2000 && globalObj.running) {
        globalObj.lastZombieTime = now;
        coordinates = getNewZombieCoordinates();
        //newZombie({id: 'z' + globalObj.lastZombieId, x: coordinates.x, y: coordinates.y});
        globalObj.lastZombieId++;
    }

    for (i in globalObj.agents) {

        if (globalObj.agents[i].type == 'player') {
            playerCount++;
        }

        if (globalObj.agents[i].logic) {
            globalObj.agents[i].logic();
        }

        for (j in globalObj.agents) {
            xDif = globalObj.agents[i].x - globalObj.agents[j].x;
            yDif = globalObj.agents[i].y - globalObj.agents[j].y;
            if (Math.abs(xDif) < globalObj.agents[i].collision.radius && Math.abs(yDif) < globalObj.agents[i].collision.radius && globalObj.agents[i].id != globalObj.agents[j].id) {
                if (globalObj.agents[i].collision[globalObj.agents[j].type]) {
                    globalObj.agents[i].collision[globalObj.agents[j].type]({i: i, j: j, xDif: xDif, yDif: yDif});
                }
            }

        }

        globalObj.agents[i].draw();

        if (globalObj.agents[i].kill) {
            delete globalObj.agents[i];
        }

    }

    return playerCount;
};

var init = function() {

    globalObj.agents = [];
    globalObj.lastZombieTime = new Date();
    globalObj.lastZombieId = 0;
    globalObj.lastBulletId = 0;
    globalObj.players = [];
    globalObj.running = true;


};

var main = function() {
    (function animloop(){
        var playerCount = eventLoop();
        if (playerCount > 0) {
            window.requestAnimationFrame(animloop);
        } else {
            reset();    
        }
    })();
};

var reset = function() {
    //alert('Everybody is dead!');
    init();
}

initTextures();

        </script>


    </body>

</html>

