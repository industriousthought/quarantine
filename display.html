
<html>

    <head>


        <link rel="stylesheet" type="text/css" href="./css/reset.css" />
        <script src="./js/mathTools.js">

        </script>
    

        <script src="./js/animationEffects.js">

        </script>

        <script src="/socket.io/socket.io.js"></script>
<script>
    
    var socket;
    function matrixMultiply(a,b) {
        var a00=a[0*3+0];
        var a01=a[0*3+1];
        var a02=a[0*3+2];
        var a10=a[1*3+0];
        var a11=a[1*3+1];
        var a12=a[1*3+2];
        var a20=a[2*3+0];
        var a21=a[2*3+1];
        var a22=a[2*3+2];
        var b00=b[0*3+0];
        var b01=b[0*3+1];
        var b02=b[0*3+2];
        var b10=b[1*3+0];
        var b11=b[1*3+1];
        var b12=b[1*3+2];
        var b20=b[2*3+0];
        var b21=b[2*3+1];
        var b22=b[2*3+2];
        return [a00*b00+a01*b10+a02*b20,a00*b01+a01*b11+a02*b21,a00*b02+a01*b12+a02*b22,a10*b00+a11*b10+a12*b20,a10*b01+a11*b11+a12*b21,a10*b02+a11*b12+a12*b22,a20*b00+a21*b10+a22*b20,a20*b01+a21*b11+a22*b21,a20*b02+a21*b12+a22*b22];
    }

function makeTranslation(tx, ty) {
  return [
    1, 0, 0,
    0, 1, 0,
    tx, ty, 1
  ];
}

function makeRotation(angleInRadians) {
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  return [
    c,-s, 0,
    s, c, 0,
    0, 0, 1
  ];
}

function makeScale(sx, sy) {
  return [
    sx, 0, 0,
    0, sy, 0,
    0, 0, 1
  ];
}
    
var loadProgram = function(gl, shaders, opt_attribs, opt_locations) {
  var program = gl.createProgram();
  for (var ii = 0; ii < shaders.length; ++ii) {
    gl.attachShader(program, shaders[ii]);
  }
  if (opt_attribs) {
    for (var ii = 0; ii < opt_attribs.length; ++ii) {
      gl.bindAttribLocation(
          program,
          opt_locations ? opt_locations[ii] : ii,
          opt_attribs[ii]);
    }
  }
  gl.linkProgram(program);

  // Check the link status
  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!linked) {
      // something went wrong with the link
      lastError = gl.getProgramInfoLog (program);
      error("Error in program linking:" + lastError);

      gl.deleteProgram(program);
      return null;
  }
  return program;
};
    

var error = function(msg) {
  if (window.console) {
    if (window.console.error) {
      window.console.error(msg);
    }
    else if (window.console.log) {
      window.console.log(msg);
    }
  }
};
    
var createShaderFromScript = function (gl, scriptId, opt_shaderType, opt_errorCallback) {
  var shaderSource = "";
  var shaderType;
  var shaderScript = document.getElementById(scriptId);
  if (!shaderScript) {
    throw("*** Error: unknown script element" + scriptId);
  }
  shaderSource = shaderScript.text;

  if (!opt_shaderType) {
    if (shaderScript.type == "x-shader/x-vertex") {
      shaderType = gl.VERTEX_SHADER;
    } else if (shaderScript.type == "x-shader/x-fragment") {
      shaderType = gl.FRAGMENT_SHADER;
    } else if (shaderType != gl.VERTEX_SHADER && shaderType != gl.FRAGMENT_SHADER) {
      throw("*** Error: unknown shader type");
      return null;
    }
  }

  return loadShader(
      gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,
      opt_errorCallback);
};

var loadShader = function(gl, shaderSource, shaderType, opt_errorCallback) {
  var errFn = opt_errorCallback || error;
  // Create the shader object
  var shader = gl.createShader(shaderType);

  // Load the shader source
  gl.shaderSource(shader, shaderSource);

  // Compile the shader
  gl.compileShader(shader);

  // Check the compile status
  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (!compiled) {
    // Something went wrong during compilation; get the error
    lastError = gl.getShaderInfoLog(shader);
    errFn("*** Error compiling shader '" + shader + "':" + lastError);
    gl.deleteShader(shader);
    return null;
  }

  return shader;
}

if (!window.requestAnimationFrame) {
  window.requestAnimationFrame = (window.webkitRequestAnimationFrame ||
                                  window.mozRequestAnimationFrame ||
                                  window.msRequestAnimationFrame ||
                                  window.oRequestAnimationFrame ||
                                  function (callback) {
                                    return window.setTimeout(callback, 17 /*~ 1000/60*/);
                                  });
}

if (!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||
                                 window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame ||
                                 window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||
                                 window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||
                                 window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||
                                 window.clearTimeout);
}


function getUrlParameters(parameter, staticURL, decode){
   /*
    Function: getUrlParameters
    Description: Get the value of URL parameters either from 
                 current URL or static URL
    Author: Tirumal
    URL: www.code-tricks.com
   */
   var currLocation = (staticURL.length)? staticURL : window.location.search,
       parArr = currLocation.split("?")[1].split("&"),
       returnBool = true;
   
   for(var i = 0; i < parArr.length; i++){
        parr = parArr[i].split("=");
        if(parr[0] == parameter){
            return (decode) ? decodeURIComponent(parr[1]) : parr[1];
            returnBool = true;
        }else{
            returnBool = false;            
        }
   }
   
   if(!returnBool) return false;  
}

var gameID = getUrlParameters('id', '', true);
var pause = true;

var getNewPlayerCoordinates = function() {
    return {x: 200, y: 200};
};

var getNewZombieCoordinates = function() {
    var locations = [
        {x: 50, y: 50},
        {x: 1150, y: 350},
        {x: 200, y: 650},

    ];
    var i = Math.floor(Math.random() * 3);

    return locations[i];
};

  var TextureMap = function(p) {
    var horizontalNum = p.horizontalNum;
    var verticalNum = p.verticalNum;
    var currentTile = [0, 0];
    var tileCount = p.tileCount;
    

    this.getTile = function(tile) {
        if (tile != null) {
            currentTile[1] = tile;
            if (currentTile[0] < tileCount[tile] - 1) {
                currentTile[0]++;
            } else {
                currentTile[0] = 0;
            } 
        }

        return {minX: (1 / horizontalNum) * currentTile[0], maxX: (1 / horizontalNum) * (currentTile[0] + 1), minY: (1 / verticalNum) * currentTile[1], maxY: (1 / verticalNum) * (currentTile[1] + 1)};

    
    };

  };

function rotatePoint(pointX, pointY, originX, originY, angle) {
    return [
        Math.cos(angle) * (pointX-originX) - Math.sin(angle) * (pointY-originY) + originX,
        Math.sin(angle) * (pointX-originX) + Math.cos(angle) * (pointY-originY) + originY
    ];
}

var Square = function(p) {
    var xMin, xMax, yMin, yMax, ys, xs, i;
    this.center = p.center;
    this.vertices = [
        [this.center[0] - (p.width / 2), this.center[1] - (p.height / 2)],
        [this.center[0] + (p.width / 2), this.center[1] - (p.height / 2)],
        [this.center[0] + (p.width / 2), this.center[1] + (p.height / 2)],
        [this.center[0] - (p.width / 2), this.center[1] + (p.height / 2)]
    ];

    this.draw = function(ctx) { 
        var i = 0;
        for (i = 0; i < this.vertices.length; i++) {  
            ctx.beginPath();
            ctx.arc(
                this.vertices[i][0], 
                this.vertices[i][1], 
                5, 0, 2 * Math.PI, false);

            ctx.fillStyle = 'green';
            ctx.fill();
        }
        ctx.beginPath();
        ctx.arc(
            this.center[0], 
            this.center[1], 
            5, 0, 2 * Math.PI, false);

        ctx.fillStyle = 'white';
        ctx.fill();

    };


    this.edges = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 0]
    ];

    this.getAxis = function(axis) {
        var i = 0;
        var output = [];
        for (i = 0; i < this.vertices.length; i++) {
            output.push(this.vertices[i][axis]);
        }
        return output;
    };


    this.rotate = function(theta) {
        var output = [];
        var i = 0;
        for (i = 0; i < this.vertices.length; i++) {  
            output[i] = rotatePoint(this.vertices[i][0], this.vertices[i][1], this.center[0], this.center[1], theta); 
        }
        this.vertices = output;
    };

    if (p.rotation) { 
        this.rotate(-1 * (p.rotation));
    }

    xs = this.getAxis(0);
    ys = this.getAxis(1);
    for (i = 0; i < xs.length; i++) {
        if (!xMin) {
            xMin = xs[i];
        } else {
            if (xMin > xs[i]) {
                xMin = xs[i];
            }
        }

        if (!xMax) {
            xMax = xs[i];
        } else {
            if (xMax < xs[i]) {
                xMax = xs[i];
            }
        }

        if (!yMin) {
            yMin = ys[i];
        } else {
            if (yMin > ys[i]) {
                yMin = ys[i];
            }
        }

        if (!yMax) {
            yMax = ys[i];
        } else {
            if (yMax < ys[i]) {
                yMax = ys[i];
            }
        }

    }

   
    this.pointInBoundary = function(x, y) {
        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
            return true;
        }
    };

    var dist2 = function(v, w) { 
        return Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2) 
    };

    var distToSegmentSquared = function(p, v, w) {
        var l2 = dist2(v, w);
        if (l2 == 0) return dist2(p, v);
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t < 0) return dist2(p, v);
        if (t > 1) return dist2(p, w);
        return dist2(p, { x: v.x + t * (w.x - v.x),
                          y: v.y + t * (w.y - v.y) });
    };

    var distToSegment = function(p, v, w) { 
        return Math.sqrt(distToSegmentSquared(p, v, w));
    };

    this.getClosestVertices = function(x, y) {
    
        var min, otherMin;
        var distances = [];
        var i = 0;
        for (i = 0; i < this.vertices.length; i++) {
            distances.push(distToSegment({x: x, y: y}, {x: this.vertices[this.edges[i][0]][0], y: this.vertices[this.edges[i][0]][1]}, {x: this.vertices[this.edges[i][1]][0], y: this.vertices[this.edges[i][1]][1]}));
        }

        for (i = 0; i < distances.length; i++) {

            if (min == null) {
                min = i;
            } else {
                if (distances[min] > distances[i]) {
                    min = i;
                }
                    
            }

        }

        return min;
    };
};

var findPerpendicularPoint = function(xp, yp, x1, y1, x2, y2) {
    var t =  ((xp - x1) * (x2 - x1) + (yp - y1) * (y2 - y1)) / (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))
    return [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
    
};

var pointInPolygon = function(numberOfVertices, xCoordinates, yCoordinates, testX, testY) {
    var i, j;
    var c = false;
    for (i = 0, j = numberOfVertices - 1; i < numberOfVertices; j = i++) {
        if ( ((yCoordinates[i] > testY) != (yCoordinates[j] > testY)) &&
         (testX < (xCoordinates[j] - xCoordinates[i]) * (testY - yCoordinates[i]) / (yCoordinates[j] - yCoordinates[i]) + xCoordinates[i]) )
           c = !c;
    }

    return c;
        
};

var length = function(x, y) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
};

var Force = function(v, type) {
    var start = new Date();
    var vec = v;
    this.kill = false;
    this.type = type;

    this.getVec = function() {
        var dif = new Date() - start;
        if (dif > 250) {
            this.kill = true;
        }
        return {x: vec.x * Math.cos((dif / 250) * (Math.PI / 2)), y: vec.y * Math.cos((dif / 250) * (Math.PI / 2))};

    };
};

</script>

<script id="2d-vertex-shader" type="x-shader/x-vertex">
attribute vec2 a_position;
attribute vec2 a_texCoord;

uniform vec2 u_resolution;
uniform mat3 u_matrix;

varying vec2 v_texCoord;


void main() {

// Multiply the position by the matrix.
  vec2 position = (u_matrix * vec3(a_position, 1)).xy;

  // convert the position from pixels to 0.0 to 1.0
  vec2 zeroToOne = position / u_resolution;

  // convert from 0->1 to 0->2
  vec2 zeroToTwo = zeroToOne * 2.0;

  // convert from 0->2 to -1->+1 (clipspace)
  vec2 clipSpace = zeroToTwo - 1.0;

  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
   v_texCoord = a_texCoord;
}
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// RJ Suggestion : Since we are using one texture at a time, we just need one 
// sampler2D defined inside our shader. So set it only ones in your code
		
// our texture
uniform sampler2D u_image0;
uniform sampler2D u_image1;
uniform sampler2D u_image2;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
// Look up a color from the texture.
vec4 textureColor = texture2D(u_image0, v_texCoord);
  if (textureColor.a < 0.5) 
    discard;
  else
    gl_FragColor = vec4(textureColor.rgb, textureColor.a);
	
	
	
}
</script>


    </head>


    <body onload="init();">
        <img id="background" src="background.png" style="position: absolute; width: 100%; height: 100%">
        <canvas id="display" style="width: 100%; height: 100%; top: 0px; left: 0px; position: absolute"> 
        </canvas>
        <canvas id="overlay" width="1200" height="750" style="z-index: 2; width: 100%; height: 100%; top: 0px; left: 0px; position: absolute"> 
        </canvas>
        <div id="1number" style="font-size:300px; position: absolute; top: 200px; left: 200px; opacity: 0">1</div>
        <div id="2number" style="font-size:300px; position: absolute; top: 200px; left: 200px; opacity: 0">2</div>
        <div id="3number" style="font-size:300px; position: absolute; top: 200px; left: 200px; opacity: 0">3</div>

        <div id="debug" style="position: absolute; top: 0px; right: 0px; width: 100px; height 300px; z-index: 2"> <br/> </div>

        <script>

// Get A WebGL context
var overlay = document.getElementById("overlay").getContext('2d');
var canvas = document.getElementById("display");
var debug = document.getElementById("debug");
canvas.setAttribute('width', '1200');
canvas.setAttribute('height', '750');
var gl = canvas.getContext("experimental-webgl");
var globalGL = {};
var globalObj = {};




// setup a GLSL program
var vertexShader = createShaderFromScript(gl, "2d-vertex-shader");
var fragmentShader = createShaderFromScript(gl, "2d-fragment-shader");
globalGL.program = loadProgram(gl, [vertexShader, fragmentShader]);
gl.useProgram(globalGL.program);

// look up where the vertex data needs to go.
globalGL.positionLocation = gl.getAttribLocation(globalGL.program, "a_position");

globalGL.translationLocation = gl.getUniformLocation(globalGL.program, "u_translation");

//Get rotation location
globalGL.rotationLocation = gl.getUniformLocation(globalGL.program, "u_rotation");

// set the resolution
globalGL.resolutionLocation = gl.getUniformLocation(globalGL.program, "u_resolution");
gl.uniform2f(globalGL.resolutionLocation, canvas.width, canvas.height);


var textures = {
    'player': {image: './hero.png', textureIndex: 0, width: 89, height: 50, texHorizontalNum: 6, texVerticalNum: 2, tileCount: [6, 5]},
    'zombie1': {image: './zombie1.png', textureIndex: 2, width: 89, height: 50, texHorizontalNum: 6, texVerticalNum: 3, tileCount: [6, 5, 2]},
    'zombie2': {image: './zombie2.png', textureIndex: 3, width: 69, height: 50, texHorizontalNum: 6, texVerticalNum: 3, tileCount: [6, 5, 2]},
    'zombie3': {image: './zombie3.png', textureIndex: 4, width: 69, height: 50, texHorizontalNum: 6, texVerticalNum: 3, tileCount: [6, 5, 2]},
    'bullet': {image: './bullet.png', textureIndex: 1, width: 4, height: 4, texHorizontalNum: 1, texVerticalNum: 1, tileCount: [1, 1]},
    'car1': {image: './car1.png', textureIndex: 5, width: 150, height: 225, texHorizontalNum: 1, texVerticalNum: 1, tileCount: [1, 1]},
    'car2': {image: './car2.png', textureIndex: 5, width: 150, height: 225, texHorizontalNum: 1, texVerticalNum: 1, tileCount: [1, 1]},
    'car3': {image: './car3.png', textureIndex: 5, width: 150, height: 225, texHorizontalNum: 1, texVerticalNum: 1, tileCount: [1, 1]},
    'car4': {image: './car4.png', textureIndex: 5, width: 150, height: 225, texHorizontalNum: 1, texVerticalNum: 1, tileCount: [1, 1]}   

};

var initTextures = function() {
    var i;
    for (i in textures) {

        (function (){
            var index = i;
            var image = new Image();
            image.onload = function() {
                textures[index].vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, textures[index].vertexBuffer);

                var xMin = 0;
                var xMax = textures[index].width;
                var yMin = 0;
                var yMax = textures[index].height;


                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    xMin, yMax,
                    xMax, yMax,
                    xMin, yMin,
                    xMin, yMin,
                    xMax, yMax,
                    xMax, yMin]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(globalGL.positionLocation);
                gl.vertexAttribPointer(globalGL.positionLocation, 2, gl.FLOAT, false, 0, 0);

                textures[index].texCoordLocation = gl.getAttribLocation(globalGL.program, 'a_texCoord');
                

                textures[index].texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, textures[index].texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    0,  1,
                    1,  1,
                    0,  0,
                    0,  0,
                    1,  1,
                    1,  0]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray( textures[index].texCoordLocation);
                gl.vertexAttribPointer(textures[index].texCoordLocation, 2, gl.FLOAT, false, 0, 0);

                // Create a texture.
                textures[index].texture = gl.createTexture();
                textures[index].u_imageLocation = gl.getUniformLocation(globalGL.program, "u_image" + textures[index].textureIndex);
                gl.uniform1i(textures[index].u_imageLocation, textures[index].textureIndex); 

                gl.bindTexture(gl.TEXTURE_2D, textures[index].texture);


                // Upload the image into the texture.
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

                // Set the parameters so we can render any size image.
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

                gl.bindTexture(gl.TEXTURE_2D, null);



            };

            image.src = textures[i].image;  
        })();
    }
};


var Agent = function (p) {

    this.id = p.id;

    if (p.textureName) {    

        this.getSpeedCurve = function() {
            var elapsedTime = new Date() - this.changeTime;
            if (this.targetSpeedScaler && (this.targetSpeedScaler > this.currentSpeedScaler)) {
                this.actualSpeedScaler = this.currentSpeedScaler + ((this.targetSpeedScaler - this.currentSpeedScaler) * Math.sin(((elapsedTime) / 250) * (Math.PI / 2))); 
                if (elapsedTime > 250) {
                    this.actualSpeedScaler = this.targetSpeedScaler;
                    this.currentSpeedScaler = this.targetSpeedScaler;
                    this.targetSpeedScaler = null;
                    this.changeTime = null;
                }
            }

            if (this.targetSpeedScaler && (this.targetSpeedScaler < this.currentSpeedScaler)) {
                this.actualSpeedScaler = this.currentSpeedScaler - ((this.currentSpeedScaler - this.targetSpeedScaler) * Math.sin(((elapsedTime) / 250) * (Math.PI / 2))); 
                if (elapsedTime > 250) {
                    this.actualSpeedScaler = this.targetSpeedScaler;
                    this.currentSpeedScaler = this.targetSpeedScaler;
                    this.targetSpeedScaler = null;
                    this.changeTime = null;
                }
            }

        };

        this.changeSpeed = function(targetScaler) {
            this.changeTime = new Date();
            this.targetSpeedScaler = targetScaler;
        };

        this.speed = 0;
        this.changeTime = null;
        this.targetSpeedScaler = null;
        this.currentSpeedScaler = 0;
        this.actualSpeedScaler = 0;
        this.textureIndex = textures[p.textureName].textureIndex;
        this.textureName = p.textureName;
        this.texture = textures[p.textureName];
        this.texHorizontalNum = textures[p.textureName].texHorizontalNum;
        this.texVerticalNum = textures[p.textureName].texVerticalNum;
        this.animationTick = 0;
        this.width = textures[p.textureName].width;
        this.height = textures[p.textureName].height;
        this.x = p.x;
        this.y = p.y;
        this.rotation = p.rotation || 0;
        this.currentAnimationSequence = 0;
        this.lastAnimationSequence = 0;
        this.texMap = new TextureMap({horizontalNum: this.texHorizontalNum, verticalNum: this.texVerticalNum, tileCount: this.texture.tileCount});
        this.currentTex = this.texMap.getTile();


        this.draw = function() {

            var tex, i;

            if (this.speed > 0 || this.currentAnimationSequence != this.lastAnimationSequence) {
                if (this.animationTick > 15 / this.speed || this.currentAnimationSequence != this.lastAnimationSequence) {
                    this.animationTick = 0;
                    tex = this.texMap.getTile(this.currentAnimationSequence);
                } else {
                    this.animationTick++;
                }
            }
            this.lastAnimationSequence = this.currentAnimationSequence;

            if (tex) {
                this.currentTex = tex;
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, this.texture.vertexBuffer);
            gl.vertexAttribPointer(globalGL.positionLocation, 2, gl.FLOAT, false, 0, 0);

            this.texture.texCoordLocation = gl.getAttribLocation(globalGL.program, 'a_texCoord');
            

            gl.bindBuffer(gl.ARRAY_BUFFER, this.texture.texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                this.currentTex.minX,  this.currentTex.maxY,
                this.currentTex.maxX,  this.currentTex.maxY,
                this.currentTex.minX,  this.currentTex.minY,
                this.currentTex.minX,  this.currentTex.minY,
                this.currentTex.maxX,  this.currentTex.maxY,
                this.currentTex.maxX,  this.currentTex.minY]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(this.texture.texCoordLocation);
            gl.vertexAttribPointer(this.texture.texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                
            var matrixLocation = gl.getUniformLocation(globalGL.program,'u_matrix');

            var centerTranslation = [-this.width / 2, -this.height / 2];
            var decenterTranslation = [this.width / 2 , this.height / 2];
            var translation = [this.x, this.y];
            var angleInRadians = this.rotation;
            var scale = [1, 1];

            // Compute the matrices
            var centerTranslationMatrix = makeTranslation(centerTranslation[0], centerTranslation[1]);
            var translationMatrix = makeTranslation(translation[0], translation[1]);
            var rotationMatrix = makeRotation(angleInRadians);
            var scaleMatrix = makeScale(scale[0], scale[1]);

            // Multiply the matrices.
            var matrix = matrixMultiply(scaleMatrix, centerTranslationMatrix);
            matrix = matrixMultiply(matrix, rotationMatrix);
            matrix = matrixMultiply(matrix, translationMatrix);

            // Set the matrix.
            gl.uniformMatrix3fv(matrixLocation, false, matrix);
            
            gl.activeTexture(gl.TEXTURE0);
            
            gl.bindTexture(gl.TEXTURE_2D, this.texture.texture);
            
            // draw
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
    }

    globalObj.agents[this.id] = this;
};

var newField = function(p) {
    var agent = new Agent({id: p.id, x: p.x, y: p.y, rotation: p.rotation});
    agent.shape = new Square({width: p.width, height: p.height, rotation: p.rotation, center: [p.x, p.y]});
    agent.type = 'field';
    agent.collision = {};
    agent.collision.edges = agent.shape.edges;


};

var newCar = function(p) {
    var agent = new Agent({textureName: 'car' + p.type, id: p.id, x: p.x, y: p.y, rotation: p.rotation});
    agent.shape = new Square({width: agent.width, height: agent.height, rotation: agent.rotation, center: [p.x, p.y]});
    agent.type = 'car';
    agent.collision = {};
    agent.collision.edges = agent.shape.edges;


};

var newBullet = function(p) {
    var agent = new Agent({textureName: 'bullet', id: p.id, x: p.x, y: p.y});
    agent.type = 'bullet';

    agent.vector = p.vector;

    agent.collision = {
        radius: 35,
        edge: function(p) {
            globalObj.agents[p.i].kill = true;
        },
        zombie: function(p) {
            globalObj.agents[p.j].forces.push(new Force(globalObj.agents[p.i].vector, 'shot'));
            globalObj.agents[p.j].health -= Math.random() * 20 + 30;
            globalObj.agents[p.i].kill = true;
            //globalObj.agents[p.j].hit = true;
        }
    };

    agent.logic = function() {
        this.x += this.vector.x * 7;
        this.y -= this.vector.y * 7;
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
            this.kill = true;
        }
    }

};

var newPlayer = function(p) {
    var agent = new Agent({textureName: 'player', id: p.id, x: p.x, y: p.y});

    agent.type = 'player';
    agent.reloading = false;
    agent.maxSpeed = 1.5;

    window.a = agent;
    agent.controller = function(data) {
        var x, y, vectorLength;

        if (data.controller == 'leftJoystick') {
            if (data.x || data.y) {
                if (this.speed == 0) {
                    this.changeSpeed(1.5);
                }

                vectorLength = length(data.x, data.y);
                if (vectorLength > this.maxSpeed) {
                    data.x = data.x * (this.maxSpeed/ vectorLength);
                    data.y = data.y * (this.maxSpeed/ vectorLength);
                }
                x = data.x * 2 * this.actualSpeedScaler;
                y = data.y * 2 * this.actualSpeedScaler;
                this.x -= x;
                this.y -= y;
                this.speed = length(x, y);

                if (!this.shooting) {
                    this.rotation = Math.atan2(data.x, data.y) + (Math.PI / 2);
                }
            } else {
                this.speed = 0;
                this.changeSpeed(0);
            }
        }
  
        if (data.controller == 'rightJoystick') {
  
            if (data.x || data.y) {
                if (this.speed > 0) {
                    this.changeSpeed(1);
                }
                this.shooting = true;
                this.rotation = Math.atan2(data.x, data.y) + (Math.PI / 2);
            } else {
                if (this.speed > 0) {
                    this.changeSpeed(1.5);
                }
                this.shooting = false;
            }

        }

    };

    agent.logic = function() {
        if (this.targetSpeedScaler) {
            this.getSpeedCurve();
        }
        if (this.shooting) {
            if (!this.reloading) {
                newBullet({
                    x: this.x + (25 * Math.cos(this.rotation)), 
                    y: this.y - (25 * Math.sin(this.rotation)), 
                    vector: {x: Math.cos(this.rotation) * 2, y: Math.sin(this.rotation) * 2}, 
                    id: globalObj.lastBulletId++});
                this.reloading = new Date();
            } else {
                if (new Date() - this.reloading > 100)
                this.reloading = false;
            }
            this.currentAnimationSequence = 1;
        } else {
            this.currentAnimationSequence = 0;
        }

    };

    agent.nick = p.nick;
    agent.collision = {
        radius: 20,
        edge: function(p) {
            globalObj.agents[p.i].x = p.x;
            globalObj.agents[p.i].y = p.y;
        },
        player: function(p) {
        
        },
        zombie: function(p) {

        }

    };

    globalObj.players[agent.id] = agent;


    //alert(agent.nick);
};


var newZombie = function(p) {
    var randomNumber = Math.random() * 9;
    var textureIndex = Math.floor(randomNumber / 3);

    
    var agent = new Agent({textureName: 'zombie' + (1 + textureIndex), id: p.id, x: p.x, y: p.y});

    agent.forces = [];
    agent.health = 100;

    agent.baseSpeed = (Math.random() * 1) + 1;
    agent.runner = 150 + Math.random() * 250;
    
    agent.collision = {
        radius: 20,
        edge: function(p) {
            globalObj.agents[p.i].x = p.x;
            globalObj.agents[p.i].y = p.y;
        },
        player: function(p) {
            delete globalObj.agents[p.j];
            delete globalObj.players[p.j];
            socket.emit('deadPlayer', {
                id: p.j
            });
        
        },
        zombie: function(p) {
            globalObj.agents[p.i].x -= (20 - p.xDif) / 50;
            globalObj.agents[p.i].y -= (20 - p.yDif) / 50;

        }

    };
    agent.type = 'zombie';
    agent.logic = function() {
        if (this.health < 0) {
            this.kill = true;
        }
        
        var closestPlayer = {};
        var i, xDif, yDif, speed, forceVector;
        for (i in globalObj.players) {
            xDif = globalObj.players[i].x - this.x;
            yDif = globalObj.players[i].y - this.y;
            if (!closestPlayer.id || Math.sqrt(Math.pow(xDif, 2) + (Math.pow(yDif, 2))) < closestPlayer.distance) {
                closestPlayer.id = i;
                closestPlayer.distance = Math.sqrt(Math.pow(xDif, 2) + (Math.pow(yDif, 2)));
                closestPlayer.xDif = xDif;
                closestPlayer.yDif = yDif;
            }

        }

        if (this.targetSpeedScaler) {
            this.getSpeedCurve();
        }

        if (this.actualSpeedScaler == 0) {
            this.changeSpeed(1);
        }

        if (closestPlayer.distance < this.runner) {
            if (this.actualSpeedScaler == 1) {
                this.changeSpeed(1.5);
            }
            this.currentAnimationSequence = 1;
        } else {
            if (this.actualSpeedScaler == 1.5) {
                this.changeSpeed(1);
            }
            this.currentAnimationSequence = 0;
        }

        this.speed = this.baseSpeed * this.actualSpeedScaler;
        
        this.rotation = Math.atan2(xDif, yDif) - (Math.PI / 2);
        if (globalObj.players[closestPlayer.id]) {
            this.x += Math.cos(this.rotation) * this.speed;
            this.y -= Math.sin(this.rotation) * this.speed;
        }

        for (i = this.forces.length; i > 0; i--) {
            if (!this.forces[i - 1].kill) {
                if (this.forces[i - 1].type == 'shot') {
                    this.currentAnimationSequence = 2;
                }
                forceVector = this.forces[i - 1].getVec();
                this.x += forceVector.x * 5;
                this.y -= forceVector.y * 5;
            } else {
                this.forces.splice(i - 1, 1);
            }
        }

    };

};


var eventLoop = function() {
    gl.clear(gl.COLOR_BUFFER_BIT);


    var i, j, k, yDif, xDif, coordinates, edge, collider, collidee, pointA, pointB, closestVertices, perpPoint;
    var polygon;
    var crossings = 0;
    var now = new Date();
    var playerCount = 0;

    if (!pause && now - globalObj.lastZombieTime > 500 && globalObj.running) {
        globalObj.lastZombieTime = now;
        coordinates = getNewZombieCoordinates();
        newZombie({id: 'z' + globalObj.lastZombieId, x: coordinates.x, y: coordinates.y});
        globalObj.lastZombieId++;
    }

    for (i in globalObj.agents) {
        collider = globalObj.agents[i];

        if (collider.type == 'player') {
            playerCount++;
        }

        if (collider.logic) {
            collider.logic();
        }

        for (j in globalObj.agents) {
            collidee = globalObj.agents[j];

            if (collidee.collision.radius && collider.collision.radius && collider.collision[collidee.type]) {
                xDif = collider.x - collidee.x;
                yDif = collider.y - collidee.y;
                if (Math.abs(xDif) < collider.collision.radius && Math.abs(yDif) < collider.collision.radius && collider.id != collidee.id) {
                    collider.collision[collidee.type]({i: i, j: j, xDif: xDif, yDif: yDif});
                }
            }

            if (collidee && collidee.collision.edges && !collider.collision.edges) {
                if (collidee.shape.pointInBoundary(collider.x, collider.y)) {
                    polygon = collidee.shape;
                    if (pointInPolygon(polygon.vertices.length, polygon.getAxis(0), polygon.getAxis(1), collider.x, collider.y)) {
                        closestEdge = polygon.getClosestVertices(collider.x, collider.y);
                        perpPoint = findPerpendicularPoint(collider.x, collider.y, polygon.vertices[polygon.edges[closestEdge][0]][0], polygon.vertices[polygon.edges[closestEdge][0]][1], polygon.vertices[polygon.edges[closestEdge][1]][0],  polygon.vertices[polygon.edges[closestEdge][1]][1]);
                        collider.collision['edge']({i: i, x: perpPoint[0], y: perpPoint[1]});

                    } 
                }
            }
        }

        if (collider.shape) {
            //collider.shape.draw(overlay);
        }
        if (collider.draw) {
            collider.draw();   
        }

        if (globalObj.agents[i].kill) {
            delete globalObj.agents[i];
        }

    }

    return playerCount;
};

var init = function() {

    globalObj.agents = [];
    globalObj.lastZombieTime = new Date();
    globalObj.lastZombieId = 0;
    globalObj.lastBulletId = 0;
    globalObj.players = [];
    globalObj.running = true;

    newCar({id: 'car0', type: '1', x: 300, y: 250, rotation: Math.PI / 4});
    newCar({id: 'car1', type: '2', x: 800, y: 200, rotation: Math.PI / .75});
    newCar({id: 'car2', type: '3', x: 200, y: 500, rotation: Math.PI / 1.75});
    newField({id: 'wall1', x: 0, y: 470, width: 50, height: 640, rotation: Math.PI});
    newField({id: 'wall2', x: 90, y: 750, width: 160, height: 50, rotation: Math.PI});
    newField({id: 'wall3', x: 275, y: 780, width: 250, height: 50, rotation: Math.PI});
    newField({id: 'wall4', x: 390, y: 630, width: 50, height: 300, rotation: Math.PI});
    newField({id: 'wall5', x: 700, y: 505, width: 600, height: 50, rotation: Math.PI});
    newField({id: 'wall6', x: 1100, y: 580, width: 280, height: 50, rotation: Math.PI * -1.2});
    newField({id: 'wall7', x: 1230, y: 420, width: 50, height: 500, rotation: Math.PI});
    newField({id: 'wall8', x: 1200, y: 100, width: 50, height: 230, rotation: Math.PI});
    newField({id: 'wall9', x: 715, y: 0, width: 1000, height: 50, rotation: Math.PI});
    newField({id: 'wall10', x: 121, y: -15, width: 219, height: 50, rotation: Math.PI});
    newField({id: 'wall11', x: -5, y: 82, width: 50, height: 160, rotation: Math.PI});
    newField({id: 'wall12', x: 5, y: 5, width: 50, height: 100, rotation: Math.PI * -1.25});

    socket = io.connect(window.location.protocol + "//" + window.location.host + '/dis' + gameID);

    socket.on('pause', function (data) {
        if (pause == true) { 
            pause = false;
        } else {
            pause = true;
        }
    });

    socket.on('ping', function (data) {
        socket.emit('pingBack', {
            id: 'display'
        });
    });

    socket.on('event', function (data) {
        if (data.newPlayer) {
            var newPos = getNewPlayerCoordinates();
            globalObj.running = true;
            newPlayer({id: data.newPlayer, nick: data.nick, x: newPos.x, y: newPos.y});
            main();
            //console.log(data.newPlayer);

        }

        if (data.controller && globalObj.players[data.id]) {
            globalObj.players[data.id].controller(data);
        }

    });

};

var main = function() {
    (function(){
        var i = 0;
        var fadeOutNumber;
        var f = function( ){
            if (i < 5 && i > 0) {
                AnimationManager.addAnimation(fadeOutNumber);
                    console.log(fadeOutNumber);
            }
            i++;
            if (i < 4) {
                var img = document.getElementById(i + 'number');
                
                var fadeInNumber = new AnimationEvent({
                    properties: {
                        opacity: {
                            start: 0,
                            stop: 1,
                            suffix: '',
                            curve: CURVES.compose(CURVES.forwardSlope, CURVES.rearSlope)

                        }
                    },
                    length: 500,
                    object: img
                });
                AnimationManager.addAnimation(fadeInNumber.add);
                fadeOutNumber = fadeInNumber.remove;
                window.setInterval(f,2000);
            }
            if (i == 5) {

                var g = function(){
                    var playerCount = eventLoop();
                    if (playerCount > 0) {
                        return true;
                    } else {
                        reset();    
                        return false;
                    }
                }
                AnimationManager.addAnimation(g);
            }
        };
        f();
    })();
};

var reset = function() {
    window.location.assign(window.location.protocol + "//" + window.location.host + '?id=' + gameID)
}

initTextures();
        </script>


    </body>

</html>

